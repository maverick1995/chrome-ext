/*

Siesta 2.0.5
Copyright(c) 2009-2013 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/products/siesta/license

*/
/**
 * Low level class which records the events of the window it's attached to. It records basic mouse and key events,
 * but does not record scroll events and other browser type events. Since it's JS based, we cannot record
 * native dialog interactions, such as alert, print, confirm etc.
 *
 * It tries to coalesce certain event patterns into higher order events (click, drag etc).
 */
Class('Siesta.Recorder.Recorder', {
    does : [
        JooseX.Observable
    ],

    has : {
        active              : null,
        eventId             : 1,

        // ignore events generated by Siesta (bypass in normal use, but for testing recorder we need it)
        ignoreSynthetic     : true,

        // The window this recorder is observing for events
        window              : null,

        // callback called anytime an event is observed
        onNewEventRecorded  : function () {
        },

        // Fire a mouseidle event if mouse doesn't move for a while.
        idleTimeout         : 3000,

        eventsToRecord      : {
            init : function () {
                return [
                    "keydown",
                    "keypress",
                    "keyup",

                    "click",
                    "dblclick",
                    "contextmenu",
                    "mousedown",
                    "mouseup"
                ];
            }
        },

        // Internal array of recorded events
        recordedEvents      : Joose.I.Array,

        moveListener        : null
    },

    
    methods : {

        initialize : function () {
            this.onUnload                   = this.onUnload.bind(this);
            this.onFrameLoad                = this.onFrameLoad.bind(this);
            this.onEvent                    = this.onEvent.bind(this);
            this.resetMouseMoveListener     = this.resetMouseMoveListener.bind(this);

            this.moveListener               = this.throttleMouseMoveListener(this.onBodyMouseMove, this.idleTimeout, this);
        },

        
        isSamePoint : function (pt1, pt2) {
            return pt1.x == pt2.x && pt1.y == pt2.y;
        },

        
        clear          : function () {
            this.recordedEvents = [];
        },

        
        // We monitor page loads so the recorder can add a waitForPageLoad action
        onUnload : function () {
            var me = this;
            
            // We need to wait for any ongoing coalescing before we fire this to keep the order intact
            setTimeout(function () {
                me.fireEvent('eventrecorded', me, { type : 'pageunload' });
            }, 200);
        },

        // After frame has loaded, stop listening to old window and restart on new frame window
        onFrameLoad    : function (event) {
            this.stop();
            
            this.attach(event.target.contentWindow);
            
            this.start();
        },

        /*
         * Attaches the recorder to a Window object
         * @param {Window} windo The window to attach to.
         **/
        attach         : function (window) {
            this.clear();
            this.window = window;
        },

        /*
         * Starts recording events of the current Window object
         **/
        start          : function () {
            var me = this;

            me.stop();

            me.active = Date.now();
            me.onStart();
            me.fireEvent('start', me);
        },

        /*
         * Stops the recording of events
         **/
        stop           : function () {
            var me = this;

            if (me.active) {
                me.active = null;
                me.onStop();
                me.fireEvent('stop', me);
            }
        },

        
        getRecordedEvents : function () {
            return this.recordedEvents;
        },

        
        onEvent  : function (e) {
            if (
            // Never trust IE
                !e.target ||
                    // Ignore events from played back test (if user plays test and records before it's stopped)
                    (this.ignoreSynthetic && e.synthetic)) return;


            var keys = Siesta.Test.Simulate.KeyCodes().keys,
                rec = {
                    type      : e.type,
                    id        : this.eventId++,
                    timestamp : Date.now(),
                    target    : e.target,
                    xy        : [e.pageX, e.pageY],
                    modKeys   : {}
                };

            // Ignore special keys which are used only in combination with other keys
            if (e.type.match('^key') &&
                (e.keyCode === keys.SHIFT ||
                e.keyCode === keys.CTRL ||
                e.keyCode === keys.ALT))
            {
                return;
            }

            var win = e.target.ownerDocument.defaultView;

            // Reset body mouse move listener
            this.resetMouseMoveListener();

            // Case of nested iframe, not yet supported
            if (win !== this.window) {
                return;
            }

            this.onNewEventRecorded(e, rec);

            if (e.type.match('^key')) {
                rec.charCode = e.charCode || e.keyCode;
                rec.keyCode = e.keyCode;
            } else {
                rec.x = rec.xy[0];
                rec.y = rec.xy[1];

                rec.button = e.button;
            }

            ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].forEach(function (id) {
                if (e[id]) rec.modKeys[id] = true;
            });

            if (this.coalesce(rec)) {

                /**
                 * @event coalesce
                 * Fires when an event is coalesced. This edits the tail of the recorded
                 * event list.
                 * @param {Siesta.Recorder.Recorder} this
                 * @param {Object} eventDescriptor The event descriptor that was coalesced.
                 */
                this.fireEvent(e.type.match('key') ? 'keycoalesce' : 'mousecoalesce', this, rec);
            } else {
                this.recordedEvents.push(rec);

                if (!e.type.match('key')) {

                    /**
                     * @event eventrecorded
                     * Fires when an event is added to the recording.
                     * @param {Siesta.Recorder.Recorder} this
                     * @param {Object} eventDescriptor The event descriptor.
                     */
                    this.fireEvent('eventrecorded', this, rec);
                }
            }
        },

        // Method which tries to identify "composite" DOM interactions such as 'click/contextmenu' (3 events), double click
        // but also complex scenarios such as 'drag'
        coalesce : function (rec) {
            var me = this,
                events = me.recordedEvents,
                length = events.length,
                tail = length && events[length - 1],
                tailPrev;

            if (!tail) {
                return false;
            }

            if (tail) {

                // Special treatments of labels with 'for' attribute which triggers double click events
                if (rec.type.match('click') && tail.type.match('click') && rec.timestamp - tail.timestamp < 100 && tail.target.getAttribute('for')) {
                    return true;
                }

                // In some situations the mouseup event may remove/overwrite the current element and no click will be triggered
                // so we need to catch drag operation on mouseup
                if (rec.type === 'click' && tail.type === 'drag') {
                    rec.type = 'drag';
                    rec.tail = tail;
                    rec.start = tail;
                    return true;
                }
            }

            if (rec.type == 'dblclick') {
                var tailPrev = events[length - 2];
                // Remove the 2nd of the two previous 'click' events, and alter type of the first
                tailPrev.type = 'dblclick';

                for (var o in tailPrev) {
                    rec[o] = tailPrev[o];
                }

                events.pop();

                return true;
            }

            if (rec.type == 'keypress' || rec.type === 'keyup') {
                var KC = Siesta.Test.Simulate.KeyCodes();
                var isSpecial = (KC.isSpecial(rec.keyCode) || KC.isSpecial(tail.keyCode) || KC.isNav(rec.keyCode));

                if (rec.type === 'keypress' && !isSpecial) {
                    rec.type = 'type';
                    rec.tail = tail;

                    return true;
                }

                // For special keys, TAB, ENTER etc
                if (rec.type === 'keyup' && isSpecial) {
                    rec.type = 'type';
                    rec.tail = tail;
                    rec.charCode = tail.charCode;

                    return true;
                }
            }

            if (rec.type == 'mouseup' &&
                rec.button == tail.button && !me.isSamePoint(rec, tail)) {
                // Change type of the initial 'mousedown' to drag, which is the only event kept in the array of recorded events
                rec.type = tail.type = 'drag';
                rec.tail = tail;
                rec.start = tail;

                return true;
            }

            if (rec.type === 'click' || rec.type === 'contextmenu') {
                tailPrev = events[length - 2];

                if (length >= 2 &&
                    // Verify tail
                    tail.type == 'mouseup' &&
                    rec.button == tail.button &&
                    rec.button == tailPrev.button &&
                    me.isSamePoint(rec, tail) &&

                    // Verify previous tail
                    tailPrev.type == 'mousedown' &&
                    rec.target == tail.target &&
                    rec.target == tailPrev.target &&
                    me.isSamePoint(rec, tailPrev)) {
                    // remove mouseup, modify mousedown event data
                    events.pop();
                    tailPrev.type = rec.type;

                    return true;
                }
            }

            return false;
        },

        
        onStart : function () {
            var me      = this,
                win     = me.window,
                doc     = win.document,
                body    = doc.body;

            me.eventsToRecord.forEach(function (name) {
                doc.addEventListener(name, me.onEvent, true);
            });

            body.addEventListener('mousemove', this.moveListener);
            $(body).bind('mouseleave', this.resetMouseMoveListener);

            win.frameElement && win.frameElement.addEventListener('load', this.onFrameLoad);
            win.addEventListener('unload', this.onUnload);
        },

        
        onStop : function () {
            var me      = this,
                win     = me.window,
                doc     = win.document,
                body    = doc.body;

            me.eventsToRecord.forEach(function (name) {
                doc.removeEventListener(name, me.onEvent, true);
            });
            
            body.removeEventListener('mousemove', this.moveListener);
            $(body).unbind('mouseleave', this.resetMouseMoveListener);

            win.frameElement && win.frameElement.removeEventListener('load', this.onFrameLoad);
            win.removeEventListener('unload', this.onUnload);
            
            clearTimeout(this.mouseMoveDeferTimer);
        },
        

        resetMouseMoveListener : function () {
            clearTimeout(this.mouseMoveDeferTimer);
        },

        // This allows a user to indicate that the cursor should be move to a certain place
        // if mouse is still for a period (idleTimeout) of time.
        onBodyMouseMove        : function (e, t) {
            var me              = this;
            var now             = Date.now();
            var recordedEvents  = me.recordedEvents;
            var lastEvent       = recordedEvents[ recordedEvents.length - 1 ];

            if (!lastEvent || now - lastEvent.timestamp >= me.idleTimeout) {
                var rec         = {
                    type        : 'mouseidle',
                    timestamp   : now,
                    id          : me.eventId++,
                    target      : t,
                    xy          : [e.pageX, e.pageY]
                };
                me.onNewEventRecorded(e, rec);

                me.fireEvent('eventrecorded', me, rec);
            }
        },
        

        throttleMouseMoveListener : function (fn, threshhold, scope) {
            var last,
                me = this;

            return function () {
                var context = scope || this;
                var now = Date.now(),
                    args = arguments;

                if (last && now < last + threshhold) {
                    clearTimeout(me.mouseMoveDeferTimer);

                    me.mouseMoveDeferTimer = setTimeout(function () {
                        last = now;
                        fn.apply(context, args);
                    }, threshhold);
                } else {
                    last = now;
                }
            };
        }
    }
    // eof methods
});
